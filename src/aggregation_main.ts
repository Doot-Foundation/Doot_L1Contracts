import {
  UInt64,
  Mina,
  AccountUpdate,
  PrivateKey,
  Proof,
  JsonProof,
  verify,
} from 'o1js';

import {
  AggregationProgram,
  AggregationProof,
  PriceAggregationArray,
  VerifyAggregationProofGenerated,
} from './Aggregation.js';

function testJsonRoundtrip<
  P extends Proof<any, any>,
  MyProof extends { fromJSON(jsonProof: JsonProof): Promise<P> }
>(MyProof: MyProof, proof: P) {
  let jsonProof = proof.toJSON();
  console.log(
    'JSON proof :',
    JSON.stringify({
      ...jsonProof,
      proof: jsonProof.proof.slice(0, 10) + '....',
    })
  );
  return MyProof.fromJSON(jsonProof);
}

// SETUP LOCAL
const doProofs = false;
let Local = await Mina.LocalBlockchain({ proofsEnabled: doProofs });
Mina.setActiveInstance(Local);

// SETUP ACCOUNTS
const deployerPK = Local.testAccounts[0].key;
const deployer = deployerPK.toPublicKey();
const zkappKey = PrivateKey.random();
const zkapp = zkappKey.toPublicKey();

// COMPILE
const { verificationKey } = await AggregationProgram.compile();
await VerifyAggregationProofGenerated.compile();

// DEPLOY
const VerifyContract = new VerifyAggregationProofGenerated(zkapp);
await Mina.transaction(deployer, async () => {
  AccountUpdate.fundNewAccount(deployer);
  await VerifyContract.deploy();
})
  .prove()
  .sign([deployerPK, zkappKey])
  .send();

console.log('\nCompleted Setup.\n');

// START GENERATION ZKPROGRAM PROOFS
const dummyInput: PriceAggregationArray = new PriceAggregationArray({
  pricesArray: [
    UInt64.from(1),
    UInt64.from(1),
    UInt64.from(1),
    UInt64.from(1),
    UInt64.from(1),
    UInt64.from(1),
    UInt64.from(1),
    UInt64.from(1),
    UInt64.from(1),
    UInt64.from(1),
  ],
});

console.log('Generated dummy input.');
// BASE CASE
let proof = await AggregationProgram.base(dummyInput);
console.log('Base Proof Generated.');
proof satisfies AggregationProof;
console.log('Base Proof Sanity Check.');
proof = await testJsonRoundtrip(AggregationProof, proof);
await verify(proof.toJSON(), verificationKey);

console.log('Completed base proof and validation.\n');

let minaPrice = UInt64.from(5248770935n);
let bitcoinPrice = UInt64.from(615439169547040n);
let ethereumPrice = UInt64.from(34421115510507n);
let solanaPrice = UInt64.from(1481398311039n);
let chainlinkPrice = UInt64.from(143095980879n);
let cardanoPrice = UInt64.from(3907233838n);
let avalanchePrice = UInt64.from(278604715977n);
let ripplePrice = UInt64.from(4749419511n);
let polygonPrice = UInt64.from(5645415935n);
let dogePrice = UInt64.from(1261024335n);

const prices: PriceAggregationArray = new PriceAggregationArray({
  pricesArray: [
    minaPrice,
    bitcoinPrice,
    ethereumPrice,
    solanaPrice,
    chainlinkPrice,
    cardanoPrice,
    avalanchePrice,
    ripplePrice,
    polygonPrice,
    dogePrice,
  ],
});

let expected = minaPrice
  .add(bitcoinPrice)
  .add(ethereumPrice)
  .add(solanaPrice)
  .add(chainlinkPrice)
  .add(cardanoPrice)
  .add(avalanchePrice)
  .add(ripplePrice)
  .add(polygonPrice)
  .add(dogePrice)
  .div(10)
  .toString();

console.log('Produced prices array successfully.');

// STEP CASE
proof = await AggregationProgram.generateAggregationProof(prices, proof);
console.log('Step Proof Generated.');
proof satisfies AggregationProof;
console.log('Step Proof Sanity Check.');
proof = await testJsonRoundtrip(AggregationProof, proof);
await verify(proof.toJSON(), verificationKey);

console.log('Expected == Output :', expected == proof.publicOutput.toString());

console.log('Completed step proof and validation.');

// VERIFY THE LATEST PROOF GENERATED USING THE VERIFY SMART CONTRACT
// The call will fail if wrong proof and vk combination.
await Mina.transaction(deployer, async () => {
  await VerifyContract.verifyAggregationProof(proof);
})
  .prove()
  .sign([deployerPK])
  .send();

console.log(
  'Validated the proof generated by ZkProgram inside the Smart Contract.'
);

// expected = UInt64.from(0).toString();
// proof = await AggregationProgram.reset(dummyInput, proof);
// console.log('Reset Proof Generated.');
// proof satisfies AggregationProof;
// console.log('Reset Proof Sanity Check.');
// proof = await testJsonRoundtrip(AggregationProof, proof);
// await verify(proof.toJSON(), verificationKey);

// console.log('Expected Output :', expected == proof.publicOutput.toString());

console.log('\n============== Completed Successfully ==============\n');
